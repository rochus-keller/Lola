

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Ll_COCO_PARSER_H__)
#define Ll_COCO_PARSER_H__

#include <QStack>
#include <Lola/LlSynTree.h>


#include "LlLexer.h"

namespace Ll {



class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Bang=2,
		_T_Hash=3,
		_T_Amp=4,
		_T_Lpar=5,
		_T_Latt=6,
		_T_Rpar=7,
		_T_Star=8,
		_T_Ratt=9,
		_T_Plus=10,
		_T_Comma=11,
		_T_Minus=12,
		_T_MinusGt=13,
		_T_Dot=14,
		_T_Colon=15,
		_T_ColonEq=16,
		_T_Semi=17,
		_T_Lt=18,
		_T_Leq=19,
		_T_Eq=20,
		_T_Gt=21,
		_T_Geq=22,
		_T_Lbrack=23,
		_T_Rbrack=24,
		_T_Hat=25,
		_T_Lbrace=26,
		_T_Bar=27,
		_T_Rbrace=28,
		_T_Tilde=29,
		_T_Keywords_=30,
		_T_BEGIN=31,
		_T_BIT=32,
		_T_BYTE=33,
		_T_CONST=34,
		_T_END=35,
		_T_IN=36,
		_T_INOUT=37,
		_T_MODULE=38,
		_T_OUT=39,
		_T_REG=40,
		_T_TS=41,
		_T_TYPE=42,
		_T_VAR=43,
		_T_WORD=44,
		_T_Specials_=45,
		_T_identifier=46,
		_T_integer=47,
		_T_Comment=48,
		_T_Eof=49,
		_T_MaxToken_=50
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(const QString& sourcePath, int line, int col, int n, Ll::Errors* err, const char* ctx, const QString& = QString() );

public:
	Ll::Lexer *scanner;
	Ll::Errors  *errors;

	Ll::Token d_cur;
	Ll::Token d_next;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser()
    {
        d_stack.push(&d_root);
        Parse();
        d_stack.pop();
    }
    
Ll::SynTree d_root;
	QStack<Ll::SynTree*> d_stack;
	void addTerminal() {
		if( d_cur.d_type != Ll::Tok_Semi && d_cur.d_type != Ll::Tok_Comma && d_cur.d_type != Ll::Tok_Dot && d_cur.d_type != Ll::Tok_Colon ){
			Ll::SynTree* n = new Ll::SynTree( d_cur ); d_stack.top()->d_children.append(n);
		}
	}



	Parser(Ll::Lexer *scanner,Ll::Errors*);
	~Parser();
	void SemErr(const char* msg);

	void Lola2();
	void module();
	void type();
	void expression();
	void SimpleType();
	void ModuleType();
	void TypeDeclaration();
	void ConstDeclaration();
	void varlist();
	void uncondExpr();
	void simpleExpr();
	void term();
	void factor();
	void variable();
	void constructor();
	void designator();
	void selector();
	void element();
	void assignment_or_instantiation();
	void statement();
	void TSgate();
	void StatementSequence();
	void iogate();
	void input();
	void output();
	void control();
	void unit();
	void paramlist();
	void VarRegDeclaration();

	void Parse();

}; // end Parser

} // namespace


#endif

